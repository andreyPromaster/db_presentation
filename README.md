# db_presentation
## Изоляция транзакций
**Транзакцией** называется множество операций, выполняемое приложением, которое переводит базу данных из одного корректного состояния в другое корректное состояние (согласованность) при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция).
Это определение объединяет три первые буквы аббревиатуры ACID. Они настолько тесно связаны друг с другом, что рассматривать одно без другого просто нет смысла. На самом деле сложно оторвать и букву D (durability). Ведь при крахе системы в ней остаются изменения незафиксированных транзакций, с которыми приходится что-то делать, чтобы восстановить согласованность данных.
***
**Aномалии в стандарте SQL**
- Потерянное обновление. Такая аномалия возникает, когда две транзакции читают одну и ту же строку таблицы, затем одна транзакция обновляет эту строку, а после этого вторая транзакция тоже обновляет ту же строку, не учитывая изменений, сделанных первой транзакцией.
- Грязное чтение. Такая аномалия возникает, когда транзакция читает еще не зафиксированные изменения, сделанные другой транзакцией.
- Неповторяющееся чтение. Аномалия неповторяющегося чтения возникает, когда транзакция читает одну и ту же строку два раза, и в промежутке между чтениями вторая транзакция изменяет (или удаляет) эту строку и фиксирует изменения. Тогда первая транзакция получит разные результаты.
- Фантомное чтение. Фантомное чтение возникает, когда транзакция два раза читает набор строк по одному и тому же условию, и в промежутке между чтениями вторая транзакция добавляет строки, удовлетворяющие этому условию (и фиксирует изменения). Тогда первая транзакция получит разные наборы строк.
- Другие аномалии (несогласованная запись и аномалия только читающей транзакции)

Уровни изоляции в PostgreSQL
Со временем на смену блокировочным протоколам управления транзакциями пришел протокол изоляции на основе снимков (Snapshot Isolation). Его идея состоит в том, что каждая транзакция работает с согласованным снимком данных на определенный момент времени, в который попадают только те изменения, которые были зафиксированы до момента создания снимка.
Такая изоляция автоматически не допускает грязное чтение. Формально в PostgreSQL можно указать уровень Read Uncommitted, но работать она будет точно так же, как Read Committed. 

   ![image](https://user-images.githubusercontent.com/55237200/129458493-403cf2b1-a4ea-4068-97ba-e1a1512f117a.png)

  Пример создания транзакции в SQL:
~~~sql
BEGIN  ISOLATION LEVEL REPEATABLE READ;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
~~~
***
# Индексы
Индексы — специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным. Это вспомогательные структуры: любой индекс можно удалить и восстановить заново по информации в таблице. Иногда приходится слышать, что СУБД может работать и без индексов, просто медленно. Однако это не так, ведь индексы служат также для поддержки некоторых ограничений целостности.
Обычно чем больше индексов, тем больше производительность запросов к базе данных. Однако при излишнем увеличении количества индексов падает производительность операций изменения данных (вставка/изменение/удаление), увеличивается размер БД, поэтому к добавлению индексов следует относиться осторожно.
Некоторые **общие принципы, связанные с созданием индексов**:
- индексы необходимо создавать для столбцов, которые используются в джойнах, по которым часто производится поиск и операции сортировки. При этом необходимо учесть, что индексы всегда автоматически создаются для столбцов, на которые накладывается ограничение primary key. Чаще всего они создаются и для столбцов с foreign key (в Access - автоматически);
- индекс обязательно в автоматическом режиме создается для столбцов, на которые наложено ограничение уникальности;
- если поиск постоянно производится по определенному набору столбцов (одновременно), то в этом случае, возможно, есть смысл создать составной индекс - один индекс для группы столбцов, нужно смотреть от возможностей СУБД;
- при внесении изменений в таблицы автоматически изменяются и индексы, наложенные на эту таблицу. В результате индекс может быть сильно фрагментирован, что сказывается на производительности.

## Типы индексов
PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN(полнотекстового поиска) и BRIN(Block Range Index). Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда CREATE INDEX создаёт индексы типа B-дерево, эффективные в большинстве случаев.
- Индекс btree, он же B-дерево, пригоден для данных, которые можно отсортировать. Иными словами, для типа данных должны быть определены операторы «больше», «больше или равно», «меньше», «меньше или равно» и «равно». Вот схематичный пример индекса по одному полю с целочисленными ключами.
Рассмотрим поиск значения в дереве по условию «индексированное-поле = выражение».

![image](https://user-images.githubusercontent.com/55237200/129477010-e843d58b-313e-4ff7-8d4c-73872bfab3b1.png)
- Хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором =. Создать такой индекс можно следующей командой:
~~~sql
CREATE INDEX имя ON таблица USING HASH (столбец);
~~~
Идея хеширования состоит в том, чтобы значению любого типа данных сопоставить некоторое небольшое число (от 0 до N−1, всего N значений). Такое сопоставление называют хеш-функцией. Полученное число можно использовать как индекс обычного массива, куда и складывать ссылки на строки таблицы (TID). Элементы такого массива называют корзинами хеш-таблицы в одной корзине могут лежать несколько TID-ов, если одно и то же проиндексированное значение встречается в разных строках.
Хеш-функция тем лучше, чем равномернее она распределяет исходные значения по корзинам. Но даже хорошая функция будет иногда давать одинаковый результат для разных входных значений — это называется коллизией.
- GiST-индексы представляют собой не просто разновидность индексов, а инфраструктуру, позволяющую реализовать много разных стратегий индексирования. Как следствие, GiST-индексы могут применяться с разными операторами, в зависимости от стратегии индексирования (класса операторов). Например, стандартный дистрибутив PostgreSQL включает классы операторов GiST для нескольких двумерных типов геометрических данных, что позволяет применять индексы в запросах с операторами:
~~~
<<
&<
&>
>>
<<|
~~~
Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица:
~~~sql
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
~~~
Если вы часто выполняете запросы вида:
~~~sql
SELECT name FROM test2 WHERE major = константа AND minor = константа;
~~~
тогда имеет смысл определить индекс, покрывающий оба столбца major и minor. Например:
~~~sql
CREATE INDEX test2_mm_idx ON test2 (major, minor);
~~~
В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Число столбцов в индексе ограничивается 32.
### Кластерный индекс
В RDBMS, понятие “кластерный” имеет много значений, но общая идея этого понятия – рассмотрение двух физических объектов как единую сущность. Например, в области построения сетей, кластер есть группа двух и более серверов, видимых как единая логическая сущность и используется для отказоустойчивости и выравнивания (балансировки) нагрузки. Например, в SQL Server кластер означает индекс, смешанный с данными. Таблица представляет собой часть индекса, или индекс представляет собой часть таблицы в зависимости от вашей точки зрения.


![image](https://user-images.githubusercontent.com/55237200/129629671-1546a688-446a-4f47-85ca-f81896bfe5e6.png)
***
# Сравнение MySQL и PostgreSQL
## Функции СУБД MySQL и PostgreSQL

![Screenshot from 2021-08-18 10-38-48](https://user-images.githubusercontent.com/55237200/129857743-2893c906-7b6b-4257-a3a6-48296c65e355.png)

   MYSQL быстрая, надежная и универсальная реляционная система управления базами данных (СУБД), самая популярная в мире: по итогам прошлого года ее использовали 39% разработчиков. 
   
   Система управления базами данных PostgreSQL считается подходящим решением для сложных операций с большими объемами данных. Причина в том, что она лучше справляется с чрезвычайными ситуациями. Считается, что у PostgreSQL больше функций, чем в других СУБД. Кроме того, PostgreSQL — расширяемая система, ее работа базируется на каталогах (подход catalog-driven). Другими словами, она хранит информацию не только о таблицах и столбцах, но и о типах данных, типах индексов, функциональных языках и так далее. Пользователи могут изменять всю эту информацию в системных каталогах, которые выглядят как обычные таблицы. Также она поддерживает высокопараллельные вычисления и NoSQL (справедливости ради, база данных MySQL также поддерживает NoSQL с версии 8.0). Другие отличительные черты базы данных PostgreSQL — это объектно-реляционная система, которая совместима с принципами ACID.

**Скорость и надежность**: отказавшись от некоторых функций SQL, система MySQL сохранила легкость, отдавая приоритет скорости и надежности. Ее скорость особенно очевидна, когда речь заходит о высокопараллельных операциях без записи в базе данных (только чтение). Это отличный выбор для определенных приложений бизнес-аналитики. Но если вам нужно выполнить много сложных запросов под большой нагрузкой, то база данных PostgreSQL может справиться лучше.

**Управление параллельным доступом посредством многоверсионности (MVCC) и соответствие ACID с движком InnoDB:** в текущих версиях MySQL движок по умолчанию — это InnoDB. Он обеспечивает функциональность MVCC и соответствие требованиям ACID. Однако из-за формата таблиц MyISAM в InnoDB на MySQL все равно могут возникнуть проблемы с поврежденными таблицами. MVCC это одна из главных причин, почему компании выбирают PostgreSQL. MVCC предоставляет одновременный доступ к базе данных множеству агентов на чтение и запись. Это устраняет необходимость каждый раз блокировать чтение-запись, когда кто-то взаимодействует с данными. Таким образом, значительно повышается эффективность управления СУБД и ее производительность.

MVCC обеспечивает такую функциональность через «изоляцию снапшотов» (как ее называет Oracle). Моментальные снимки (снапшоты) представляют состояние данных в определенный момент времени.
- OC
- Какие языки программирования поддерживают
- Поддержка пользователей

## Чем отличается программирование под каждую СУБД

Нужно знать о трех различиях в программировании БД MySQL и PostgreSQL:
- **Чувствительность к регистру**

База данных MySQL не различает регистр символов в запросах, так что запросы не обязательно должны совпадать по регистру со строками в базе данных. PostgreSQL различает регистр. Строки в запросах должны в точности совпадать с полями в базе данных, иначе запрос не будет выполнен.
- **Наборы символов и строки по умолчанию**

В некоторых версиях MySQL необходимо преобразовать наборы символов и строки в UTF-8. В базе данных PostgreSQL нет такой необходимости. Более того, в PostgreSQL вообще не допускается синтаксис UTF-8.
- **Функции IF и IFNULL вместо CASE**

В MySQL можно спокойно использовать операторы IF и IFNULL. В базе данных PostgreSQL они не работают, а вместо них необходимо использовать оператор CASE.


## Что выбрать: MySQL vs PostgreSQL

Выбор между MySQL и PostgreSQL часто сводится к следующим вопросам:
- Вам нужна многофункциональная СУБД, способная обрабатывать сложные запросы и поддерживать массивные базы данных? Тогда выбирайте базу данных PostgreSQL.
- Нужна более легкая БД, относительно простая в настройке и управлении, быстрая, надежная и понятная? Выбирайте базу данных MySQL.

Тем не менее, что решение не всегда так очевидно. Приходится искать компромисс, учитывая преимущества и недостатки обеих СУБД.
***
# Нормализация
Нормализация – это процесс (процедура) приведения таблиц базы данных к ряду нормальных форм (НФ) с целью избежания избыточности в базе данных, аномалий вставки, редактирования и удаления данных. Таблицы могут иметь неэффективную или не подходящую структуру, которую нужно нормализовать. Нормализация предусматривает разбивку исходной таблицы (отношения) на несколько новых таблиц (отношений).

Правильное применение механизма нормализации к базе данных дает следующие взаимосвязанные преимущества:

- минимизируются затраты на сохранение данных (избыточность данных). Другими словами, уменьшается размер базы данных;
- с возрастанием размера базы данных не так заметно возрастают временные затраты на доступ к данным;
- отсутствуют аномалии модификации в базе данных. К аномалиям модификации относятся аномалии вставки, редактирования и удаления данных.

Процесс нормализации включает в себя использование так называемых нормальных форм. На сегодняшний день известны следующие нормальные формы (рисунок 1):

- первая нормальная форма (1НФ);
- вторая нормальная форма (2НФ);
- третья нормальная форма (3НФ);
- нормальная форма Бойса-Кодда (НФБК);
- четвертая нормальная форма (4НФ);
- пятая нормальная форма (5НФ).

## Первая нормальная форма

Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

Например, есть таблица «Автомобили»:

![image](https://user-images.githubusercontent.com/55237200/129963143-7464e65b-0e64-4c6a-8356-1e2510dd6de0.png)

## Вторая нормальная форма

Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(ПК).

Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

Например, дана таблица:

![image](https://user-images.githubusercontent.com/55237200/129963368-fe87c6fb-4404-451c-8e8c-f86e9efbb738.png)

## Третья нормальная форма

Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

Рассмотрим таблицу:

![image](https://user-images.githubusercontent.com/55237200/129963466-bec7b975-2015-4610-b128-d19b2668c85e.png)

Таблица находится во 2НФ, но не в 3НФ.
В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина.
Таким образом, в отношении существуют следующие функциональные зависимости: Модель → Магазин, Магазин → Телефон, Модель → Телефон.
Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.

## Нормальная форма Бойса-Кодда

Таблица должна находиться в третьей нормальной форме. Здесь все как обычно, т.е. как и у всех остальных нормальных форм, первое требование заключается в том, чтобы таблица находилась в предыдущей нормальной форме, в данном случае в третьей нормальной форме;
Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов.
Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кодда.

Главное правило нормальной формы Бойса-Кодда (BCNF) звучит следующим образом:

**Часть составного первичного ключа не должна зависеть от неключевого столбца.**

![image](https://user-images.githubusercontent.com/55237200/129967428-f044844f-285b-4ecc-9aa9-4bc0ad56cbe6.png)


И если говорить о реальных данных, то нормализация до четвертой нормальной формы, как и до всех последующих, в современном мире практически не встречается. Если четвертую нормальную форму еще как-то можно представить и даже встретить данные, нормализованные до этой формы, то встретить данные, нормализованные до 5 или 6 нормальной формы, практически невозможно.
*** 
# Django ORM vs SQLAlchemyORM

## Разные подходы к отображению
Django ORM использует паттерн active record, а SQLAlchemy – data mapper. Если коротко, то разница между этими подходами заключается в том, что active record подразумевает, что каждая строка в базе данных будет обёрнута в отдельный python-объект. А подход data mapper позволяет управлять этим отображением. SQLAlchemey использует реализацию Data Mapper, которая действует как средний уровень между вашим приложением и базой данных и передает данные между ними, сохраняя при этом их соединение независимо друг от друга. Это обеспечивает большую гибкость между двумя уровнями, а также более эффективное использование базы данных.

## Разная гибкость
Django ORM – часть фреймворка Django, которая позволяет очень просто делать определённое подмножество всех сайтов. Django ORM обладает теми же свойствами: более-менее типичные запросы на ней можно сделать очень легко. А вот со сложными запросами Django ORM не справится.

SQLAlchemy наоборот: позволяет создавать очень сложные запросы, но в среднем формирование запроса будет сложнее.

Чаще всего именно это приводит к необходимости использовать SQLAlchemy в проектах на Django: в некоторых местах нужно сделать особо сложные запросы, с которыми не справится Django ORM, поэтому именно в этих местах используют SQLAlchemy.

***
## Полезные ссылки
[Как устроены базы данных](https://habr.com/ru/company/oleg-bunin/blog/358984/)

[Что такое изоляция и почему это важно](https://habr.com/ru/company/postgrespro/blog/442804/)

[PostgreSQL или MySQL: какая из этих реляционных СУБД лучше впишется в ваш проект](https://mcs.mail.ru/blog/postgresql-ili-mysql-kakaya-iz-etih-relyacionnyh-subd)

[Нормализация. Понятие и необходимость применения. Аномалии модификации. Примеры](https://www.bestprog.net/ru/2020/10/17/databases-normalization-concept-and-necessity-of-application-modification-anomalies-examples-ru/)

[Полезный цикл статей о нормализации](https://info-comp.ru/boyes-codd-normal-form)
